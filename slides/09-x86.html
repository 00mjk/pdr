<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS 2150: 09-x86 slide set</title>
    <meta name="description" content="A set of slides for a course on Program and Data Representation">
    <meta name="author" content="Aaron Bloomfield">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="reveal.js/css/reveal.min.css">
    <link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
    <link rel="stylesheet" href="css/pdr.css">
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css"><!-- For syntax highlighting -->
    <script><!-- If the query includes 'print-pdf', use the PDF print sheet -->
      document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="js/dhtmlwindow.js"></script>
    <script type="text/javascript" src="js/canvas.js"></script>
    <link rel="stylesheet" href="css/dhtmlwindow.css" type="text/css">
  </head>

  <body onload="canvasinit()">
    <div id="dhtmlwindowholder"><span style="display:none"></span></div>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section data-markdown id="cover"><script type="text/template">
# CS 2150
&nbsp;
### Program and Data Representation
### Spring 2014
&nbsp;
<center><small>[Aaron Bloomfield](http://www.cs.virginia.edu/~asb) / [aaron@virginia.edu](mailto:aaron@virginia.edu) / [@bloomfieldaaron](http://twitter.com/bloomfieldaaron)</small></center>
<center><small>Repository: [github.com/aaronbloomfield/pdr](http://github.com/aaronbloomfield/pdr) / [&uarr;](index.html) / <a href="09-x86.html?print-pdf"><img class="print" width="20" src="images/print-icon.png"></a></small></center>
<center><small>Themes: [default](?#/cover), [sky](?theme=sky#/cover), [beige](?theme=beige#/cover), [simple](?theme=simple#/cover), [serif](?theme=serif#/cover), [night](?theme=night#/cover), [moon](?theme=moon#/cover), [solarized](?theme=solarized#/cover)</small></center>
&nbsp;  
&nbsp;  
## x86 (assembly language)
	</script></section>

	  <section>
<h2>CS 2150 Roadmap</h2>
<table class="wide">
  <tr><td colspan="3"><p class="center">Data Representation</p></td><td></td><td colspan="3"><p class="center">Program Representation</p></td></tr>
  <tr>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>string<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>int x[3]<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>char x<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>0x9cd0f0ad<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>01101011</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/red-double-arrow.png" height="500" alt="vertical red double arrow"></td>
    <td class="top">&nbsp;<br>Objects<br>&nbsp;<br>Arrays<br>&nbsp;<br>Primitive types<br>&nbsp;<br>Addresses<br>&nbsp;<br>bits</td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>Java code<br>&nbsp;<br>&nbsp;<br>C++ code<br>&nbsp;<br>&nbsp;<br>C code<br>&nbsp;<br>&nbsp;<br>x86 code<br>&nbsp;<br>&nbsp;<br>IBCM<br>&nbsp;<br>&nbsp;<br>hexadecimal</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/green-double-arrow.png" height="500" alt="vertical green double arrow"></td>
    <td class="top">&nbsp;<br>High-level language<br>&nbsp;<br>Low-level language<br>&nbsp;<br>Assembly language<br>&nbsp;<br>Machine code</td>
  </tr>
</table>
	  </section>

	<section data-markdown><script type="text/template">
# Contents
&nbsp;  
[Introduction to x86](#/introduction)  
[x86 Instruction Set](#/x86insts)  
[Calling Conventions](#/callingconv)  
[Callee Rules](#/callee)  
[Caller Rules](#/caller)  
[Activation Records](#/actrecs)  
[x86 Examples](#/examples)  
	</script></section>


	<section>

	  <section id="introduction" data-markdown><script type="text/template">
# Introduction to x86
	  </script></section>

	  <section>
<h2>History of x86</h2>
<p><a href="https://en.wikipedia.org/wiki/File:C4004_%28Intel%29.jpg"><img alt="Intel 4004" src="images/09-x86/C4004.jpg"></a></p>
<table class="transparent"><tr><td>
<ul>
<li>1971: 4004, 4-bit words</li>
<li>1972: 8008, 8-bit words</li>
<li>1978: 8086, 16-bit words</li>
<li>1982: 80286</li>
<li>1985: 80386, 32-bit words</li>
<li>1989: 80486</li>
<li>1993: Pentium</li>
</ul>
</td><td>
<ul>
<li>1995: Pentium Pro</li>
<li>1997: Pentium II</li>
<li>1998: Pentium III</li>
<li>2000-2008: Pentium IV</li>
<li>2005-2008: Pentium D</li>
<li>2006-2011: Core 2</li>
<li>2008-present: Core i3, i5, i7</li>
</ul>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## IBCM vs. x86: Registers
![x86 registers](images/09-x86/x86-register-diagram.svg)
	  </script></section>

	  <section data-markdown><script type="text/template">
## IBCM vs. x86: Fetch Execute Cycle (same)
```
while(power is on) {
	IR := mem[PC]
	PC := PC + 1 (word) // 32-bits in x86
	execute instruction in IR
}
```
- PC = program counter
- IR = instruction register
	  </script></section>

	  <section>
<h2>Declaring Variables in x86</h2>
<table class="transparent"><tr><td>
<p>Directives</p>
<ul>
<li>byte = 1 byte (DB) declare byte</li>
<li>word = 2 bytes (DW)</li>
<li>double = 4 bytes (DD)</li>
<li>quadword = 8 bytes (DQ)</li>
</ul>
<p>&nbsp;</p>
<p><code>x DUP (y)</code> directive means "repeat y, x times"</p>
</td><td>
<pre><code>section .data
a	DB	23
b	DW	?
c	DD	3000
d	DQ	-800
x	DD	1, 2, 3
y	DB	8 DUP(0)
str	DB	`hello’, 0
z	DD	50 DUP(?)</code></pre>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## mov command
- `mov <dest> <src>`
- Where dest and src can be:
  - A register
  - A combination of registers and constants
  - Variable name
  - Pointer: [ebx]
  - (but with a few exceptions we'll see shortly)
	  </script></section>

	  <section>
<h2>Addressing Memory</h2>
<table class="transparent"><tr><td class="top">
<ul>
<li>Up to <i>2 registers</i> and one <i>32-bit signed constant</i> can be added together to compute a memory address<br>&nbsp;</li>
<li>Futhermore, one register can be pre-multiplied by 2, 4, 8<ul>
    <li>word-align</li>
    <li>double-align</li>
    <li>quadword-align</li>
</ul></li></ul>
</td><td style="width:50px"></td><td class="top">
<pre><code>mov eax, ebx
mov eax, [ebx]
mov [var], ebx
mov eax, [esi-4]
mov [esi+eax], cl
mov edx, [esi+ 4*ebx]</code></pre>
<p>&nbsp;</p>
<p>Incorrect: (why?)</p>
<pre><code>mov eax, [ebx – ecx]
mov [eax + esi + edi], ebx
mov [4*eax + 2*ebx], ecx</code></pre>
</td></tr></table>
	  </section>

	  <section>
<table class="transparent"><tr><td class="top">

<table class="transparent">
<tr><td class="top" colspan="2"><h2>Example</h2></td></tr>
<tr><td class="top"><p class="center">Source code:</p><pre><code>mov ecx, eax
mov edx, [ebx]
mov esi, [edx+eax+4]
mov [esi], 45
mov [a], 15
lea edi, [a]</code></pre></td>
<td style="width:50px"></td>
<td class="top">
<p class="center">Registers:</p>
<table class="transparent">
<tr><td>eax</td><td class="border" style="width:100px">100</td></tr>
<tr><td>ebx</td><td class="border" style="width:100px">104</td></tr>
<tr><td>ecx</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="1">100</span></td></tr>
<tr><td>edx</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="2">8</span></td></tr>
<tr><td>esi</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="3">200</span></td></tr>
<tr><td>edi</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="6">300</span></td></tr>
</table>
</td></tr></table>

</td><td style="width:50px"></td><td class="top">
<p class="center">Memory:</p>
<table class="transparent">
<tr><td>100</td><td class="border" style="width:100px"></td></tr>
<tr><td>104</td><td class="border" style="width:100px">8</td></tr>
<tr><td>108</td><td class="border" style="width:100px"></td></tr>
<tr><td>112</td><td class="border" style="width:100px">200</td></tr>
<tr><td>116</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px"></td></tr>
<tr><td>200</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="4">45</span></td></tr>
<tr><td>204</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px"></td></tr>
<tr><td>a:&nbsp;300</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="5">15</span></td></tr>
<tr><td>304</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px"></td></tr>
</table>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## `mov eax, [4*esi - edx]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax, [4*esi + 4]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax, [4*esi + edx+ 8]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax, [esi + 4*edx]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax + 4, [esi]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## Memory addressing restrictions
- The destination cannot be a constant (duh!)
- You cannot access memory twice in one instruction
  - As the CPU does not have enough time to do so
  - So the following are invalid:
```
mov [eax] [var]
mov [eax+4] [ebx]
```
	  </script></section>

	</section>

	<section>

	  <section data-markdown id="x86insts"><script type="text/template">
# x86 Instruction Set
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Instruction Set
- Data movement instructions
- Arithmetic instructions
- Logical instructions
- Control instructions
	  </script></section>

	  <section data-markdown><script type="text/template">
## Data Movement Instructions, part 1
- `mov`
  - We've seen this in detail
- `push`
  - push operand onto stack (4 bytes)
  - First decrements ESP (stack pointer) by 4 (stack grows DOWN)
```
push eax
push [var]
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Data Movement Instructions, part 2
- `pop`
  - pop top element of stack to memory or register, increment stack pointer (ESP) by 4
  - value is written to the parameter
```
pop eax
pop [var]
```
- `lea` (load effective address)
  - place address specified
```
lea eax, [var]
lea edi, [ebx+4*esi]
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Arithmetic Instructions, part 1
- `add`, `sub`
```
add <reg>, <reg>
add <reg>, <mem>
add <mem>, <reg>
add <reg>, <constant>
add <mem>, <constant>
```
  - adds (or subtracts), storing result in first operand
- Similar restrictions as with data movement instructions:
  - Destination cannot be a constant
  - Memory cannot be accessed twice
	  </script></section>

	  <section data-markdown><script type="text/template">
## Arithmetic Instructions, part 2
- `inc`, `dec` (increment and decrement by one)
```
inc <reg>
inc <mem>
```
  - Specific examples:
```
dec eax
inc [var]
```
- imul
```
imul <reg32>, <reg32> (or <mem>)
imul <reg32>, <reg32> (or <mem>), <con>
```
- idiv (divide 64-bit integer in EDX:EAX) by operand
```
idiv ebx
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Logical Instructions
- `and`, `or`, `xor`
```
and <reg>, <reg>
and <reg>, <mem>
and <mem>, <reg>
```
  - Specific examples:
```
and eax, 0fH
xor ecx, ecx
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 1
- `jmp <label>`
  - go to instruction address specified by label
- `cmp`
  - cmp operand1, operand2
    - Operand1 can be <reg> or <mem>
    - Operand2 can be <reg>, <mem>, or <con>
    - Can't access memory twice!
  - Sets the *machine status word*
- jCC
  - Uses the machine status word
    - Which holds info about the results of the last instruction
  - Example: `je <label>`
    - Jump when condition code equal is set
  - Others: `jne`, `jz`, `jg`, `jge`, `jl`, `jle`, `js`, etc.
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 2
- `call <label>`
  - Subroutine call
  - Pushes current code address onto  stack, then unconditionally jumps to label
- `ret`
  - Subroutine return
  - Pops the return address from the stack, then jumps to that address
	  </script></section>

	  <section>
<h2>Writing Basic x86 Assembly</h2>
<table class="transparent">
<tr><td><pre><code>int n = 5;
int i =1;
int sum = 0;
while(i <= n){
    sum += i;
    i++;
}</code></pre></td>
<td style="width:50px"></td>
<td><pre><code>section .data
n	DD 5
i	DD 1
sum	DD 0

section .text
loop:  	mov ecx, [i]
	cmp ecx, [n]
	jg endOfLoop
	add [sum], ecx
	inc [i]
	jmp loop
endOfLoop:
</code></pre></td></tr></table>
	  </section>

	</section>


	<section>

	  <section id="callingconv" data-markdown><script type="text/template">
# Calling Conventions
	  </script></section>

	  <section data-markdown><script type="text/template">
## Example
```
int max(int x, int y) {
    int theMax = (x > y) ? x : y;
    return theMax;
}

int main() {
    int a =5, b = 6;
    int maxVal = max(a,b);
    cout << "Max value: " << maxVal << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling Conventions
- What is a calling convention?
  - A set of rules/expectations between functions
    - How (and where) are *parameters* passed?
    - Which *registers* does the calling function expect to be preserved?
    - Where should *local variables* be stored?
    - How/where should results be *returned* from functions?
- Why?
  - Separate programmers can
    - share code more easily
    - develop libraries 
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention
- Why C's calling convention?
  - It's important
  - Can be used with C and C++ code
  - Can enable calling C library functions from assembly code
    - Or other languages
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention
- Uses hardware stack (memory)
  - Stack *grows down*, towards lower memory addresses
  - x86 instructions used for calling convention
    - `pop`
    - `push`
    - `call`
    - `ret`
  - Using a stack for calling convention is implemented on most processors.  Why?
    - Recursion
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention Overview
- Answers to questions
  - Parameters: passed on the stack
  - Registers: saved on the stack
  - Local variables: placed in memory on the stack
  - Return value: eax register
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling Convention Overview
- The sets of rules
  - Caller: the function which calls another function
  - Callee: the function which is called by another function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller vs. Callee
```
void foo() {
  // some function code ...
}

int main() {
    foo();
    return 0;
}
```

- `main()` is the *caller*
- `foo()` is the *callee*
	  </script></section>

	  <section data-markdown><script type="text/template">
## Register usage
- One register is used for the return value: eax
- Three registers may be modified by the callee: eax, ecx, edx
  - If the caller wants to keep those values, they need to be saved by pushing them onto the stack
  - And note eax is where the return value goes
- Three registers may not be modified by a subroutine call: ebx, edi, esi
  - If the subroutine wants to modify them, it needs to back them up first (onto the stack) and restore them before returning
- Two registers should almost never be modified directly: ebp, esp
  - There is an exception: ebp is modified in one case by the callee
	  </script></section>

	  <section data-markdown><script type="text/template">
## Varying number of parameters
- Three ways to have a variable number of parameters:
  - Method overloading
    - `Foo::bar(int)` and `Foo::bar(int, float)`
  - Default parameters
    - `Foo::bar (int x = 3)`
  - Variable arguments
    - As seen next...
	  </script></section>

	  <section data-markdown><script type="text/template">
## Variable number of arguments in C/C++

This code adapted from [here](http://www.cprogramming.com/tutorial/lesson17.html)

```
#include <cstdarg>
#include <iostream>
using namespace std;

double average ( int num, ... ) {
  va_list arguments;
  double sum = 0;
  va_start ( arguments, num );
  for ( int x = 0; x < num; x++ )
    sum += va_arg ( arguments, double );
  va_end ( arguments );
  return sum / num;
}

int main() {
  cout<< average ( 3, 12.2, 22.3, 4.5 ) <<endl;
  cout<< average ( 5, 3.3, 2.2, 1.1, 5.5, 3.3 ) <<endl;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Dissection of the average() function
- Create a data structure to hold the list of arguments:
```
va_list arguments;
```
- Initialize the arguments to store all values after num:
```
va_start ( arguments, num );
```
- Loop until all numbers are added:
```
for ( int x = 0; x < num; x++ )
```
- Adds the next value in argument list to sum:
```
      sum += va_arg ( arguments, double );
```
- Clean up the list:
```
va_end ( arguments );
```
- Return the average:
```
return sum / num;
```
	  </script></section>


	  <section data-markdown><script type="text/template">
## The C equivalent of cout is a function called printf
```
printf ("A %s, a %s, a %s: %s!", "man", 
		"plan", "canal", "Panama");
printf ("A percent sign: %%");
printf ("An int: %d\n", i);
printf ("A float with 2 decimal digits: %.2f", 
		float_value);
```
Output:
```
A man, a plan, a canal, Panama!
A percent sign: %
An int: 3
A float with 2 decimal digits: 3.14
```
	  </script></section>

	</section>


	<section>

	  <section id="caller" data-markdown><script type="text/template">
# Caller Rules
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Summary
- Prologue
  - BEFORE the function body
- Function body
- Epilogue
  - AFTER the function body, before the return
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Summary
- Prologue
  - Tasks to take care of BEFORE calling a subroutine
- Epilogue
  - Tasks to complete AFTER subroutine call returns
- (not really called this, but I use this to parallel the equivalent components in the Callee convention)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules/Responsibilities
- *Before* calling the function (the prologue)
  - Save registers that might be needed after the call (eax, ecx, edx)
  - Push parameters on the stack
- *Call* the function
  - `call` instruction places return address in stack
- *After* the called function returns (the epilogue)
  - Remove parameters from stack
  - Restore saved registers
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules ("Prologue")
1. Caller-saved registers
   - Registers which the calling function (caller) must save (push onto the stack) ONLY if it wants the values preserved.
   - eax, ecx, edx
2. Parameters
   - Pushed in *reverse order* (last parameter first) onto stack
3. Call the subroutine
  - Use the `call` instruction
    - pushes the return address onto the stack and branches to the subroutine
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules ("Epilogue")
1. Remove parameters
   - Parameters pushed onto stack must be removed
     - Restore stack to the state before the call
   - What is done with the parameters?
2. Return value
   - If any, held in eax
3. Restore caller-saved registers
   - eax, ecx, edx
   - `pop` them off the stack (Caller can assume no other registers were modified)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
We'll see this code in the following slides:
```
int myFunc(int a, int b, int c){
    int x
    // some code
    return result;
}

int main() {
    int x = 1, z = 3;
    int retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
```
push edx         ; caller wants edx to be preserved

                 ; int retVal = myFunc(x, 123, z);
push [z]         ; Push last param first
push 123         ; push constant 123
push eax         ; push first param last

call myFunc     ; call the function

add esp, 12      ; clean up stack
pop edx          ; restore saved edx value

; return value of myFunc is now available in eax 
; (if there is any return value)
```
	  </script></section>

	  <section>
<h2>Stack Memory Visualization for myFunc</h2>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>&larr; esp</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	</section>


	<section>

	  <section id="callee" data-markdown><script type="text/template">
# Callee Rules
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Summary
- Prologue
  - Tasks to perform BEFORE executing the function body
- Epilogue
  - Tasks to perform AFTER executing function body, but BEFORE leaving function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
We'll see this code in the following slides:
```
int myFunc(int a, int b, int c){
    int x
    // some code
    return result;
}

int main() {
    int x = 1, z = 3;
    int retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules (Prologue)
Before the body of the function:

1. Push ebp and copy esp into ebp
```
push ebp
mov ebp, esp
```
  - ebp: snapshot of esp when subroutine starts
    - Parameters and local variables are known distances/offsets from this pointer value
2. Allocate local variables
   - make space on stack (decrement stack pointer)
	  </script></section>

	  <section>
<h2>Callee Rules (Prologue)</h2>
<ol start="3">
<li>Save callee-save registers<ul>
    <li>ebx, edi, esi (push them onto stack)</li>
    <li>only need to do this if callee intends to use them, otherwise, no need to save their contents</li>
</ul></li></ol>
<p>&nbsp;</p>
<p>THEN, perform body of the function</p>
	  </section>

	  <section data-markdown><script type="text/template">
## Callee Rules (Epilogue)
1. Return value saved to eax
2. Restore callee-saved registers
   - `pop` from stack (in reverse order from which pushed)
3. Deallocate local variables
```
mov esp, ebp
```
4. Restore base pointer
```
pop ebp
```
5. Return
```
ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example
With a bit more code in the `myFunc()` body:
```
int myFunc(int a, int b, int c) {
    int result;
    result = c;
    result += b;
    return result;
}

int main(){
    int x = 1, z=3;
    int retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (1)
```
section .text
myFunc:
                ; prologue
push ebp        ; save old base pointer
mov ebp, esp    ; set new base pointer
sub esp, 4      ; save room for 1 local var (result)
push ebx        ; save callee-save registers
push esi        ; both will be used by myFunc
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (2)
```
                     ; subroutine body
mov eax, [ebp+8]     ; param 1 to eax
mov esi, [ebp+12]    ; param 2 to esi
mov ebx, [ebp+16]    ; param 3 to ebx
mov [ebp-4], ebx     ; put ebx into local var
add [ebp-4], esi     ; add esi into local var
mov eax, [ebp-4]     ; mov contents of local var to eax
                     ; (return value/final result)
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (3)
```
                ; subroutine epilogue
pop esi         ; recover callee save registers
pop ebx         ; REVERSE of when pushed
mov esp, ebp    ; deallocate local var(s)
pop ebp         ; restore caller's base pointer
ret             ; pop top value from stack, jump there
```
	  </script></section>

	  <section>
<h2>Stack Memory Visualization for myFunc just as it is called</h2>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&#8598; ebp</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&larr; esp</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section>
<h2>Stack Memory Visualization for myFunc</h2>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>[ebp+16]</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>[ebp+12]</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>[ebp+8]</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&larr; ebp</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">local variable</td><td style="width:25px"></td><td>[ebp-4]</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">saved value of ebx</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px">saved value of esi</td><td style="width:25px"></td><td>&larr; esp</td></tr>
</table>
	  </section>

	</section>


	<section>

	  <section id="actrecs" data-markdown><script type="text/template">
# Activation Records
	  </script></section>

	  <section>
<h2>Activation Records</h2>
<table class="transparent"><tr>
<td class="top">
<ul>
<li>Every time a sub-routine is called, a number of things are pushed onto the stack:<ul>
    <li>Registers</li>
    <li>Parameters</li>
    <li>Old base/stack pointers</li>
    <li>Local variables</li>
    <li>Return address</li>
</ul></li>
<li>All of this is called the <i>activation record</i></li>
</ul>
</td><td>
<img alt="x86 activation record" src="images/09-x86/x86-activation-record.svg">
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## Memory management
- The binary program takes up a fixed amount of space
  - The size of the file (say, 10k, as an example)
- There are two types of memory that need to be handled:
  - Dynamic memory (via new, malloc(), etc.)
    - This is stored on the *heap*
  - Static memory (on the stack)
    - This is where the activation records are kept
	  </script></section>

	  <section data-markdown><script type="text/template">
## Memory management
- The binary program starts at the 'beginning' of the 2<sup>32</sup> = 4 Gb of memory
- The heap starts right after this
- The stack starts at the end of this 4 Gb of memory, and grows backward
  - They could have chosen the heap to grow backwards, but they didn't
- As a program progresses, they both grow towards the middle
  - And never the two shall meet
	  </script></section>

	  <section>
<h2>Consider this subroutine</h2>
<pre><code>void security_hole() {
    char buffer[10];
    scanf ("%s", buffer); // and older C input routine
}</code></pre>
<p>The stack looks like (with sizes in parenthesis):</p>
<p>&nbsp;</p>
<table class="transparent"><tr>
  <td class="border">esi (4)</td>
  <td class="border">edi (4)</td>
  <td class="border">buffer (10)</td>
  <td class="border">ebp (4)</td>
  <td class="border">ret addr (4)</td>
</tr></table>
<p>&nbsp;</p>
<ul>
<li>Addresses increase to the right (the stack grows to the left)</li>
<li class="fragment">What happens if the value stored into buffer is 11 bytes long?</li>
<li class="fragment">What if it is exactly 18 bytes long?<ul>
    <li class="fragment">We overwrite the return address!</li>
</ul></li>
</ul>
	  </section>

	  <section data-markdown><script type="text/template">
## Buffer overflow attack
- When you read in a string (etc.) that goes beyond the size of the buffer
  - Hence 'buffer overflow'
- You can then overwrite the return address
  - And set it to your own code
  - For example, code that is included later on in the string
- We may see an example of this, if there is time in the course...
	  </script></section>

	</section>


	<section>

	  <section id="examples" data-markdown><script type="text/template">
# x86 Examples
	  </script></section>

	  <section data-markdown><script type="text/template">
## A note about x86 compatibility
- We are using nasm as our assembler for the x86 labs
- The x86 code samples in this slide set are either:
  - "Generic" x86 examples that could work in nasm if put into a proper program
    - In the same way that you have seen C++ code snippets
  - Or the output from "clang++ -S" (and probably some other flags)
    - This code will *NOT* work with nasm, but will work with clang++ (which we aren't really using anyway for our assembly)
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Examples
All are in the slides/code/09-x86/ directory in the github repo  
&nbsp;  
Code we'll see:

- int absolute_value(int x)
- int max(int x, int y)
- bool compare_string(const char \*theStr1, const char \*theStr2)
- int fib(int n)
	  </script></section>

	  <section data-markdown><script type="text/template">
## int absolute_value(int x)
```
int absolute_value(int x) {
    if(x<0)        // if x is negative
        x = -x;    // negate x
    return x;      // return x
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_abs.cpp
```
extern "C" int absolute_value(int x);

int absolute_value(int x) {
    if( x < 0 )    // if x is negative
        x = -x;    // negate x
    return x;      // return x
}

int main(){
    int theValue=0;
    cout << "Enter a value: " << endl;
    cin >> theValue;
    int theResult = absolute_value(theValue);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Assembly for absolute_value
```
; Standard prologue
push ebp
mov ebp, esp

; procedure body
mov eax, [ebp + 8]    ; eax <- x
cmp eax, 0            ; x == 0 ?
jge end_of_proc       ; if pos goto end
neg eax               ; negate x

end_of_proc:
; Standard epilogue
mov esp, ebp
pop ebp
ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Generating assembly with clang++
- Using the -S flag, we can generate assembly from C/C++ code
- Note that the format is a bit different
  - Register specification, dest/source order, etc.
- So we need to use the following flags:
```
-mllvm --x86-asm-syntax=intel
```
- The formatting is still different, but the idea is the same
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly for absolute_value
Note the source / destination order is reversed
```
absolute_value:
.LFB1401:
    pushl    %ebp
.LCFI0:
    movl     %esp, %ebp
.LCFI1:
    cmpl     $0, 8(%ebp)
    jns      .L2
    negl     8(%ebp)
.L2:
    movl     8(%ebp), %eax
    popl     %ebp
    ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## All those extra opcodes...
- `movl`, `pushl`, `compl`, `negl`, `popl`
  - the 'l' part means 'long' (i.e. 32 bits, so the assembler doesn’t have to assume)
- `jns` means jump if not signed (i.e. if positive)
- `$0` is the constant 0
- `8(%ebp)` is [ebp+8]
  – i.e. where the parameters are
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly for absolute_value
This is when using `-mllvm --x86-asm-syntax=intel`
```
absolute_value:
.LFB1428:
        push    %ebp
.LCFI0:
        mov     %ebp, %esp
.LCFI1:
        cmp     DWORD PTR [%ebp+8], 0
        jns     .L2
        neg     DWORD PTR [%ebp+8]
.L2:
        mov     %eax, DWORD PTR [%ebp+8]
        pop     %ebp
        ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly output on Macs
- With g++ (what we used last year), Darwin (i.e., Mac OS X) did not support the `--masm=intel` flag
- But I don't know what clang++ will do...
  - Can anybody test this?
- So you are stuck using the "other" format
  - With the source / destination order reversed
- You can compile it on a the Linux VirtualBox image, if you want the 'correct' order
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_abs_c.c
```
#include <stdio.h>

int absolute_value(int x) {
    if(x<0)        // if x is negative
        x = -x;    // negate x
    return x;    // return x
}

int main(){
    int theValue=0;
    printf ("Enter a value: \n");
    scanf ("%d", &theValue);
    int theResult = absolute_value(theValue);
    printf ("The result is: %d\n", theResult);
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## C++ assembly vs. C assembly
- Notice how much cleaner C translates into assembly versus C++
- Compare files [test_abs.s](code/09-x86/test_abs.s.html) ([src](code/09-x86/test_abs.s)) and [test_abs_c.s](code/09-x86/test_abs_c.s.html) ([src](code/09-x86/test_abs_c.s))
	  </script></section>

	  <section data-markdown><script type="text/template">
## int max(int x, int y)
```
int max(int x, int y) {
    int theMax;
    if(x > y)         // if x > y then it is max
        theMax = x;
    else              // else y is the max
        theMax = y;
    return theMax;    // return the max
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_max.cpp
```
#include <iostream>
using namespace std;
extern "C" int max(int x, int y);

// the max function from the previous slide

int main(){
    int theValue1=0, theValue2=0;
    cout << "Enter value 1: " << endl;
    cin >> theValue1;
    cout << "Enter value 2: " << endl;
    cin >> theValue2;

    int theResult = max(theValue1, theValue2);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max()
Using `-mllvm --x86-asm-syntax=intel`
```
max:
.LFB1428:
        push    %ebp
.LCFI0:
        mov     %ebp, %esp
.LCFI1:
        sub      %esp, 16
.LCFI2:
        mov     %eax, DWORD PTR [%ebp+8]
        cmp     %eax, DWORD PTR [%ebp+12]
        jle     .L2
        mov     %eax, DWORD PTR [%ebp+8]
        mov     DWORD PTR [%ebp-4], %eax
        jmp     .L4
.L2:
        mov     %eax, DWORD PTR [%ebp+12]
        mov     DWORD PTR [%ebp-4], %eax
.L4:
        mov     %eax, DWORD PTR [%ebp-4]
        leave
        ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max() using --O2
Using `-mllvm --x86-asm-syntax=intel` and `-O2`
```
max:
.LFB1428:
        push    %ebp
.LCFI0:
        mov     %ebp, %esp
.LCFI1:
        mov     %edx, DWORD PTR [%ebp+8]
        mov     %eax, DWORD PTR [%ebp+12]
        cmp     %eax, %edx
        jge     .L2
        mov     %eax, %edx
.L2:
        pop     %ebp
        ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max() without the 'extern "C"' line
Using `-mllvm --x86-asm-syntax=intel`
```
_Z3maxii:
.LFB1428:
        push    %ebp
.LCFI0:
        mov     %ebp, %esp
.LCFI1:
        sub      %esp, 16
.LCFI2:
        mov     %eax, DWORD PTR [%ebp+8]
        cmp     %eax, DWORD PTR [%ebp+12]
        jle       .L2
        mov     %eax, DWORD PTR [%ebp+8]
        mov     DWORD PTR [%ebp-4], %eax
        jmp      .L4
.L2:
        mov     %eax, DWORD PTR [%ebp+12]
        mov     DWORD PTR [%ebp-4], %eax
.L4:
        mov     %eax, DWORD PTR [%ebp-4]
        leave
        ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## bool compare_string(char \*theStr1, char \*theStr2)
```
bool compare_string (const char *theStr1, 
                     const char *theStr2) {
    // while *theStr1 is not NULL terminator
    // and the current corresponding bytes are equal
    while( (*theStr1 != NULL) 
            && (*theStr1 == *theStr2) )
    {
        theStr1++;        // increment the pointers to 
        theStr2++;        // the next char / byte
    }
    return (*theStr1==*theStr2);
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_string_compare.cpp
```
#include <iostream>
#include <string>
using namespace std;

extern "C" bool compare_string(const char* theStr1, 
                               const char* theStr2);

// code for compare_string here

int main(){
    string theValue1, theValue2;
    cout << "Enter string 1: " << endl;
    cin >> theValue1;
    cout << "Enter string 2: " << endl;
    cin >> theValue2;
    bool theResult = compare_string(theValue1.c_str(),
                                    theValue2.c_str());
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for compare_string()
Using `-mllvm --x86-asm-syntax=intel`
```
_compare_string:
    push    ebp
    mov    ebp, esp
L11:
    mov    eax, DWORD PTR [ebp+8]
    cmp    BYTE PTR [eax], 0
    je    L12
    mov    eax, DWORD PTR [ebp+8]
    mov    edx, DWORD PTR [ebp+12]
    movzx    eax, BYTE PTR [eax]
    cmp    al, BYTE PTR [edx]
    jne    L12
    inc    DWORD PTR [ebp+8]
    lea    eax, [ebp+12]
    inc    DWORD PTR [eax]
    jmp    L11
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## int fib(int n)
```
int fib(int n) {
    if((n==0) || (n==1))
        return 1;
    return fib(n-1) + fib(n-2);
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_fib.cpp
```
#include <iostream>
using namespace std;
extern "C" int fib(int n);

int fib(int n) {
    if((n==0) || (n==1))
        return 1;
    return fib(n-1) + fib(n-2);
}

int main(){
    int theValue = 0;
    cout << "Enter value for fib(): " << endl;    
    cin >> theValue;
    int theResult = fib(theValue);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section>
<h2>x86 assembly for fib()</h2>
<p>Using <code>-mllvm --x86-asm-syntax=intel</code></p>
<table class="transparent"><tr>
<td><pre><code>fib:
.LFB1428:
    push  %ebp
.LCFI0:
    mov   %ebp, %esp
.LCFI1:
    push  %ebx
.LCFI2:
    sub   %esp, 8
.LCFI3:
    cmp   DWORD PTR [%ebp+8], 0
    je    .L2
    cmp   DWORD PTR [%ebp+8], 1
    jne   .L4
.L2:
    mov   DWORD PTR [%ebp-8], 1
    jmp   .L5</code></pre>
</td>
<td><pre><code>.L4:
    mov   %eax, DWORD PTR [%ebp+8]
    sub   %eax, 1
    mov   DWORD PTR [%esp], %eax
    call  fib
    mov   %ebx, %eax
    mov   %eax, DWORD PTR [%ebp+8]
    sub   %eax, 2
    mov   DWORD PTR [%esp], %eax
    call  fib
    add   %ebx, %eax
    mov   DWORD PTR [%ebp-8], %ebx
.L5:
    mov   %eax, DWORD PTR [%ebp-8]
    add   %esp, 8
    pop   %ebx
    pop   %ebp
    ret
</code></pre></td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## Didn't that violate the convention?
- Not really!
- The convention states what the stack must look like when a subroutine is invoked
- The steps given in this slide set are to help learn the convention
- So as the stack was set up correctly, the convention was follows
	  </script></section>

	  <section>
<h2>Do we need to even use ebp?</h2>
<table class="transparent">
<tr><td class="top"><ul>
<li>If we know that the number of local variables will be fixed...<ul>
    <li>... then we can offset everything from esp instead</li>
</ul></li>
<li>This saves the push/pop ebp operations</li>
<li>clang++ likes to do this...</li>
<li>But this is not always possible if a program uses dynamic memory on the <i>stack</i></li>
</td><td><img alt="x86 activation record" src="images/09-x86/x86-activation-record.svg"></td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## RISC versus CISC
- RISC
  - Reduced instruction set computer
  - Fewer and simpler instructions (maybe 50 or so)
  - Less chip complexity means they can run fast
- CISC
  - Complex instruction set computer
  - More and more complex instructions (300-400 or so)
  - More chip complexity means harder to make run fast
	  </script></section>

    </section>



      </div>

    </div>

    <div id="calibratediv" style="display:none">
      <div id="calibratecanvasdiv">
        <canvas id="calibratecanvas" width="300" height="300">Your browser does not support the canvas tag</canvas>
      </div>
      <p style="text-align:center">Click the center of the target<br><a href="#" onClick="calibratewin.close(); return false">Close window</a></p>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.min.js"></script>
    <script src="js/settings.js"></script>

  </body>
</html>
