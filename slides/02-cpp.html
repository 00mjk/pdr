<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>CS 2150: 02-cpp slide set</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="reveal.js/css/reveal.min.css">
    <link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
    <link rel="stylesheet" href="pdr.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section>
	  <h1>CS 2150</h1>
	  <p>&nbsp;</p>
	  <h3>Program and Data Representation</h3>
	  <h3>Spring 2014</h3>
	  <p>&nbsp;</p>
	  <p class="center">
	    <small>By <a href="http://www.cs.virginia.edu/~asb">Aaron Bloomfield</a> / <a href="mailto:aaron@virginia.edu">aaron@virginia.edu</a> / <a href="http://twitter.com/bloomfieldaaron">@bloomfieldaaron</a><br>&nbsp;<br>
		<a href="http://github.com/aaronbloomfield/pdr">github.com/aaronbloomfield/pdr</a></small>
	  </p>
	  <p>&nbsp;</p>
	  <p>&nbsp;</p>
	  <h2>C++</h2>
	</section>

	<section>
	  <h1>Contents</h1>
	  <p>&nbsp;</p>
	  <p><a href="#/intro">Introduction to C++</a></p>
	  <p><a href="#/functions">Functions</a></p>
	  <p><a href="#/classes">Classes</a></p>
	  <p><a href="#/rational">Rational Example</a></p>
	  <p><a href="#/preprocessor">Pre-Processor</a></p>
	  <p><a href="#/pointers">Pointers</a></p>
	  <p><a href="#/dynamic">Dynamic Memory Allocation</a></p>
	  <p><a href="#/references">References</a></p>
	  <p><a href="#/parameters">Parameter Passing</a></p>
	  <p><a href="#/advanced">Sample (advanced) code</a></p>
	</section>

	<section>

	  <section id="intro">
	    <h1>Introduction to C++</h1>
	  </section>

	  <section>
	    <h2>Why C++ and not Java?</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>It's good to learn a second language</li>
	      <li>C++ is widely used
		<ul>
		  <li>Can be more efficient</li>
		  <li>More control</li>
		</ul>
	      </li>
	      <li>C++ will let us "get under the hood" more
		<ul>
		  <li>Data and program representation in memory</li>
		  <li>Memory allocation</li>
		</ul>
	      </li>
	    </ul>
	  </section>

	  <section>
	    <h2>A brief history lesson</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>C was created in 1972 by Dennis Ritchie
		<ul>
		  <li>Intended to be terse, quick to write, and efficient</li>
		</ul>
	      </li>
	      <li>C++ was created in 1985 by Bjarne Stroustrup
		<ul>
		  <li>Added classes while being backwards compatible</li>
		  <li>Has pretty terrible syntax!</li>
		</ul>
	      </li>
	    </ul>
	  </section>

	  <section>
	    <h2>Hello World --&nbsp; Java vs. C++</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>// Java
public class HelloWorld {
    public static void main(String [] args) {
        System.out.println("Hello World!");
    }
}</code></pre>
	    <p>&nbsp;</p>
	    <pre><code data-trim>// C++
#include &lt;iostream&gt;
using namespace std;
int main() {
    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>Differences</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>main()</li>
	      <li>Preprocessor
		<ul>
		  <li>#include</li>
		</ul>
	      </li>
	      <li>using namespace std;</li>
	      <li>Output</li>
	    </ul>
	  </section>

	  <section>
	    <h2>main()</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Not a part of any class
		<ul>
		  <li>called a <i>function</i></li>
		</ul>
	      </li>
	      <li>Must be global</li>
	      <li>Must have a return type of int
		<ul>
		  <li>By convention, main returns 0</li>
		</ul>
	      </li>
	    </ul>
	  </section>

	  <section>
	    <h2>Preprocessor</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Examples
		<ul>
		  <li>#include &lt;iostream&gt; // System file</li>
		  <li>#include &quot;ListNode.h&quot; // user-defined file</li>
		</ul>
	      </li>
	      <li>What this does
		<ul>
		  <li>Compiler inserts the contents of the file in the place where the #include statement appears</li>
		</ul>
	      </li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ Compilation Process Overview</h2>
	    <p>&nbsp;</p>
	    <ol>
	      <li>Preprocess source file
		<ul>
		  <li>handle #includes and any other # statements</li>
		</ul>
	      </li>
	      <li>Compile resulting file</li>
	      <li>Link the resulting files from Step 2 (more on this later..)</li>
	    </ol>
	  </section>

	  <section>
	    <h2>using Directive</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Similar to Java's <span class="tt">import</span>
		<ul>
		  <li>Allows the programmer to not have to type the full class name </li>
		</ul>
	      </li>
	    </ul>
	    <table class="wide">
	      <tbody>
		<tr>
		  <td>
		    <pre><code data-trim>// C++
#include &lt;iostream&gt;
using namespace std;
int main() {
    cout &lt;&lt; "Hello World!" &lt;&lt; endl;
    return 0;
}</code></pre>
		  </td>
		  <td>
		    <pre><code data-trim>// C++
#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; "Hello World!" 
              &lt;&lt; std::endl;
    return 0;
}</code></pre>
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </section>

	  <section>
	    <h2>I/O</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Basic I/O</li>
	    </ul>
	    <pre><code data-trim>// use iostream library
#include &lt;iostream&gt;
using namespace std;
int main() {
    int x;
    cout &lt;&lt; "Enter a value for x: ";
    cin &gt;&gt; x;
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>C++ Primitive Types</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>int
		<ul>
		  <li>Can be 16, 32, 64 bits depending on the platform</li>
		</ul>
	      </li>
	      <li>float</li>
	      <li>double</li>
	      <li>char
		<ul>
		  <li>C++ generally uses 8 bit ASCII encoding (more on this later)</li>
		</ul>
	      </li>
	      <li>bool</li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ Operators and Expressions</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>if statement
		<ul>
		  <li>in C++ condition can be either int or bool</li>
		  <li>if ( x = 0 )
		    <ul>
		      <li>This will NOT cause a compiler error in C++</li>
		    </ul>
		  </li>
		  <li>if ( i )
		    <ul>
		      <li>This is valid!</li>
		    </ul>
		  </li>
		</ul>
	      </li>
	    </ul>
	  </section>

	  <section>
	    <h2>Operators and Expressions</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>loops, same as Java
		<ul>
		  <li>while, for, do while, break, continue</li>
		</ul>
	      </li>
	    </ul>
	  </section>
	  
	  <section>
	    <h2>Compiler choice</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>In the past we have used g++
		<ul>
		  <li>From GNU's Compiler Collection</li>
		</ul>
	      </li>
	      <li>We are now using clang (from LLVM)
		<ul>
		  <li>It has MUCH better error messages</li>
		</ul>
	      </li>
	      <li>Consider:
	    <pre><code data-trim>#include &lt;iostream&gt;
using namespace std;
int main() {
    // note the spelling mistake on the next
    // line where 'cout' is spelled 'cotut'
    cotut &lt;&lt; "Hello World";
    return 0;
}</code></pre>
	      </li>
	    </ul>
	  </section>

	  <section>
	    <h2>Error comparison</h2>
	    <p>&nbsp;</p>
	    <table>
	      <tr><td class="middle">g++:</td><td><img width="850" alt="g++ error message" src="images/02-cpp/g++-error-message.png"></td></tr>
	      <tr><td class="middle">clang++:</td><td><img width="850" alt="clang++ error message" src="images/02-cpp/clang++-error-message.png"></td></tr>
	    </table>
	  </section>

	</section>

	<section>

	  <section id="functions">
	    <h1>Functions</h1>
	  </section>

	  <section>
	    <h2>Functions</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Methods not member of a class</li>
	    </ul>
	    <pre><code data-trim>
#include &lt;iostream&gt;
using namespace std;

ret_type func_name(int a, int b, ...) {
    &lt;function body&gt;
}

int main() {
    ...
    z = func_name(x, y, ...);
    ...;
    return 0;
}
</code></pre>
	  </section>

	  <section>
	    <h2>Declaring mutually<br>recursive functions</h2>
	    <p>&nbsp;</p>
	    <table class="wide">
	      <tr>
		<td><pre><code data-trim><span class="fragment">bool even (int x);</span></code><code data-trim>
bool odd (int x) {
    if ( x == 0 )
        return false;
    else
        return even (x-1);
}</code></pre></td>
		<td><pre><code data-trim><br>
bool even (int x) {
    if ( x == 0 )
        return true;
    else
      return odd (x-1);
}</code></pre></td>
	      </tr>
	    </table>
	  </section>

	  <section>
	    <h2>Function Prototypes</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>C++ compiler process files top to bottom
		<ul>
		  <li>order of appearance matters without a <strong>function prototype</strong></li>
		</ul>
	      </li>
	      <li>General form of a prototype:</li>
	    </ul>
	    <pre><code data-trim>ret_type func_name (int a, int b, ...);</code></pre>
	  </section>

	  <section>
	    <h2>Example</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#include &lt;iostream&gt;
using namespace std;

int max(int a, int b);	// prototype

int main() {
    int x=37; int y=52;
    cout &lt;&lt; max(x,y) &lt;&lt; endl;
    return 0;
}

// actual function implementation
int max(int a, int b) {
    return (a>b) ? a : b;
}</code></pre>
	  </section>

	</section>

	<section>

	  <section id="classes">
	    <h1>Classes</h1>
	  </section>

	  <section>
	    <h2>Java -- IntCell.java</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>public class IntCell {  
    public IntCell() // default constructor
        { this(0); }

    // one parameter constructor
    public IntCell(int initialValue)
        { storedValue = initialValue; }

    // accessor member function
    public int getValue()
        { return storedValue; }

    // mutator member function
    public void setValue(int val)
        { storedValue = val; }</code></pre>
	  </section>

	  <section>
	    <h2>Java -- IntCell.java</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>    // private data member
    private int storedValue;

    // main()
    public static void main(String [] args) {
        IntCell m1 = new IntCell();
        IntCell m2 = new IntCell(37);
        System.out.println(m1.getValue() + " " + 
                 m2.getValue());
    }
}</code></pre>
	    </section>

	  <section>
	    <h2>How Would You Translate This Java Source into C++?</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Need 3 files
		<ol>
		  <li>Header file that contains class definition: IntCell.h</li>
		  <li>C++ file that contains class implementation: IntCell.cpp</li>
		  <li>C++ file that contains a main(): TestIntCell.cpp</li>
		</ol></li>
	      <li>Note the separation of interface and implementation!</li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ IntCell: TestIntCell.cpp</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#include &lt;iostream&gt; 
#include "IntCell.h" 
using namespace std; 

int main( ) { 
    IntCell m1; // calls the default constructor
    IntCell m2( 37 );
    cout &lt;&lt; m1.getValue( ) &lt;&lt; " " &lt;&lt; m2.getValue( ) 
         &lt;&lt; endl;
    m1 = m2;
    m2.setValue( 40 );
    cout &lt;&lt; m1.getValue( ) &lt;&lt; " " &lt;&lt; m2.getValue( ) 
         &lt;&lt; endl;
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>C++ IntCell: IntCell.h</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#ifndef INTCELL_H
#define INTCELL_H

class IntCell {
  public:
    explicit IntCell( int initialValue = 0 );

    int getValue( ) const;
    void setValue( int val );

  private:
    int storedValue;
    int max(int m);
};
#endif
</code></pre>
	  </section>

	  <section>
	    <h2>C++ IntCell: IntCell.cpp</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#include "IntCell.h" 

IntCell::IntCell( int initialValue ) : storedValue( initialValue ) { 
}

int IntCell::getValue( ) const { 
    return storedValue; 
}

void IntCell::setValue( int val ) { 
    storedValue = val; 
} 

int IntCell::max(int m){
    return 1;
}</code></pre>
	  </section>

	  <section>
	    <h2>C++ IntCell: IntCell.h (again)</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#ifndef INTCELL_H
#define INTCELL_H

class IntCell {
  public:
    explicit IntCell( int initialValue = 0 );

    int getValue( ) const;
    void setValue( int val );

  private:
    int storedValue;
    int max(int m);
};
#endif</code></pre>
	  </section>

	  <section>
	    <h2>C++ IntCell: TestIntCell.cpp (again)</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#include &lt;iostream&gt; 
#include "IntCell.h" 
using namespace std; 

int main( ) { 
    IntCell m1; // calls the default constructor
    IntCell m2( 37 );
    cout &lt;&lt; m1.getValue( ) &lt;&lt; " " &lt;&lt; m2.getValue( ) 
         &lt;&lt; endl;
    m1 = m2;
    m2.setValue( 40 );
    cout &lt;&lt; m1.getValue( ) &lt;&lt; " " &lt;&lt; m2.getValue( ) 
         &lt;&lt; endl;
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>Separate Compilation</h2>
	    <p>&nbsp;</p>
	    <p>(diagram)</p>
	  </section>

	</section>

	<section>

	  <section id="rational">
	    <h1>Rational Example</h1>
	  </section>

	  <section>
	    <h2>The General Conversion Process</h2>
	    <p>&nbsp;</p>
	    <ol>
	      <li>Create .h file with class definition
		<ul>
		  <li>Member function signatures, no implementations</li>
		</ul></li>
	      <li>Create .cpp file containing member function implementations</li>
	      <li>Create .cpp file containing main()</li>
	    </ol>
	  </section>

	  <section>
	    <h2>Reminders</h2>
	    <p>&nbsp;</p>
	    <ol>
	      <li>int main()</li>
	      <li>Input/Output
		<ul>
		  <li>#include &lt;iostream&gt;</li>
		  <li>using namespace std;</li>
		  <li>cout &lt;&lt; varName &lt;&lt; " " &lt;&lt; endl;</li>
		</ul></li>
	      <li>Class syntax
		<ul>
		  <li>public and private sections</li>
		  <li>semi-colon at the end of class declaration</li>
		  <li>ClassName::</li>
		</ul></li>
	    </ol>
	  </section>

	  <section>
	    <h2>I'll Explain Later, But For Now...</h2>
	    <p>&nbsp;</p>
	    <ol>
	      <li>Printing
		<ul>
		  <li>instead of '+' use &lt;&lt; to concatenate items to print</li>
		</ul></li>
	      <li>Remove this and new from conversion</li>
	    </ol>
	  </section>

	  <section>
	    <h2>Rational.h</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#ifndef RATIONAL_H 
#define RATIONAL_H 
class Rational { 
  public: 
    Rational(); // default constructor 
    ~Rational();         // destructor 
    Rational(int numerator, int denominator); 
    void print() ; 
    Rational times(Rational b); 
    Rational plus(Rational b); 
    Rational reciprocal();
    Rational divides(Rational b); 
  private: 
    int num; // the numerator 
    int den; // the denominator 
    int gcd(int m, int n); 
};
#endif</code></pre>
	  </section>

	  <section>
	    <h2>Rational.cpp</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#include "Rational.h" 
#include &lt;iostream&gt; 
using namespace std; 

// default constructor: initialize to 0/1
Rational::Rational() : num(0), den(1) { } 

void Rational::print() { 
    if (den == 1)
        cout &lt;&lt; num &lt;&lt; "" &lt;&lt; endl;
    else 
        cout &lt;&lt; num &lt;&lt; "/" &lt;&lt; den &lt;&lt; endl;
}</code></pre>
	  </section>

	  <section>
	    <h2>Rational.cpp</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>Rational Rational::times(Rational b) { 
    return Rational(num * b.num, den * b.den); 
}</code></pre>
	  </section>

	  <section>
	    <h2>Rational.cpp</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>Rational::Rational(int numerator, int denominator) { 
    if (denominator == 0) {
       cout &lt;&lt; "Denominator is zero" &lt;&lt; endl; 
    int g = gcd(numerator, denominator);
    num = numerator / g; 
    den = denominator / g; 
}</code></pre>
	  </section>

	  <section>
	    <h2>TestRational.cpp</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#include "Rational.h" 

int main() { 
    Rational x, y, z; 
    // 1/2 + 1/3 = 5/6 
    x = Rational(1, 2); 
    y = Rational(1, 3); 
    z = x.plus(y); 
    z.print(); 
    // ... other code very much like above
}</code></pre>
	  </section>

	  <section>
	    <h2>.h vs. .cpp?</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>C++ naming convention
		<ul>
		  <li>.h     // header files
		    <ul>
		      <li>function prototypes</li>
		      <li>class definitions</li>
		      <li>macro definitions</li>
		      </ul>
		  </li>
		  <li>.cpp    // implementation files</li>
		</ul></li>
	      <li>Definitions may only appear in 1 place
		<ul>
		  <li>compiler errors: "multiply defined XYZ"</li>
		</ul></li>
	    </ul>
	  </section>

	</section>

	<section>

	  <section id="preprocessor">
	    <h1>Pre-processor</h1>
	  </section>

	  <section>
	    <h2>Preprocessing</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>#include
		<ul>
		  <li>Direct copy of file specified to location specified</li>
		  <li>In general, only #include .h files.</li>
		</ul></li>
	      <li>#ifndef
		<ul>
		  <li>"if not defined"</li>
		  <li>other preprocessor directives: #ifdef, #if</li>
		</ul></li>
	      <li>#define
		<ul>
		  <li>Defines a macro (direct text replacement)</li>
		</ul>
	    <pre><code data-trim>define TRUE 0
if(TRUE == 0) {...}
#define MY_OBJECT_H</code></pre>
	      </li>
	      <li>#endif
		<ul>
		  <li>specifies the end of any #if</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>#define</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Can define a constant
	    </ul>
	    <pre><code data-trim>define PI 3.14159
...
area = PI * r * r;</code></pre>
	    <ul>
	      <li>Can just define an identifier</li>
	    </ul>
	    <pre><code data-trim>#define FOO
#ifdef FOO   // is true!
#ifndef FOO  // is false!</code></pre>
	  </section>

	  <section>
	    <h2>What problems arise?</h2>
	    <p>&nbsp;</p>
	    <p>(table)</p>
	  </section>

	  <section>
	    <h2>Preventing #include loops</h2>
	    <p>&nbsp;</p>
	    <p>(table)</p>
	  </section>

	</section>

	<section>

	  <section id="pointers">
	    <h1>Pointers</h1>
	  </section>

	  <section>
	    <h2>Pointer Variables</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Stores a memory address of another object
		<ul>
		  <li>Can be a primitive type or a class type</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>Examples of Pointers</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>int * x;</li>
	      <li>char *y;</li>
	      <li>Rational * rPointer;</li>
	    </ul>
	  </section>

	  <section>
	    <h2>What Types are These?</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>float * num1</li>
	      <li>double num2</li>
	      <li>Rational fraction1</li>
	      <li>Square * square1</li>
	      <li>int num3</li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ Syntax: * </h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Asterisk *
		<ul>
		  <li>In a definition</li>
		  <li>defines pointer type</li>
		  <li>int x</li>
		  <li>In an expression</li>
		  <li>"dereferences"</li>
		  <li>evaluates object to which the pointer points</li>
		  <li>x = 2</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ Syntax: &amp;</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Ampersand &amp;
		<ul>
		  <li>In a definition</li>
		  <li>defines a reference type (more on this later)</li>
		  <li>In an expression</li>
		  <li>"address of"</li>
		  <li>x = &amp;y</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>Pointer Variables</h2>
	    <p>&nbsp;</p>
	    <p>(diagram)</p>
	  </section>

	  <section>
	    <h2>x_pointer = &amp;x</h2>
	    <p>&nbsp;</p>
	    <p>(image)</p>
	  </section>

	  <section>
	    <h2>Dereferencing and Assigning</h2>
	    <p>&nbsp;</p>
	    <p>(diagram)</p>
	  </section>

	  <section>
	    <h2>*x_pointer = 2</h2>
	    <p>&nbsp;</p>
	    <p>(image)</p>
	  </section>

	  <section>
	    <h2>x_pointer = &amp;y</h2>
	    <p>&nbsp;</p>
	    <p>(diagram)</p>
	  </section>

	  <section>
	    <h2>x_pointer = &amp;y</h2>
	    <p>&nbsp;</p>
	    <p>(image)</p>
	  </section>

	  <section>
	    <h2>*x_pointer = 3</h2>
	    <p>&nbsp;</p>
	    <p>(diagram)</p>
	  </section>

	  <section>
	    <h2>Binky's Pointer Fun</h2>
	    <p>&nbsp;</p>
	    <p>(insert video) http://www.youtube.com/watch?v=UvoHwFvAvQE</p>
	  </section>

	  <section>
	    <h2>What Types are These?</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>char * x;</li>
	      <li>int **y;</li>
	      <li>Rational *rNumber1;</li>
	      <li>Square **blah;</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Pointer Pitfalls: Uninitialized Pointers</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Cause runtime errors</li>
	      </ul>
	    <pre><code data-trim>int n = 30;
int * p;
*p = n;    //ERROR!!!</code></pre>
	    <ul>
	      <li>p does not have a valid memory address!</li>
	      <li>A common initializer value used by programmers is NULL</li>
	    </ul>
<pre><code data-trim>int *p=NULL; // better code, then add code to check for NULL value</code></pre>
	  </section>

	  <section>
	    <h2>swap()</h2>
	    <p>&nbsp;</p>
<pre><code data-trim>void swap(int * x, int * y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}</code></pre>
	  </section>

	  <section>
	    <h2>Calling swap()</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>int main() {
    int a=0;
    int b=3;
    cout &lt;&lt; "Before swap(): a: " &lt;&lt; a &lt;&lt; "b: " 
         &lt;&lt; b &lt;&lt; endl;
    swap(&amp;b,&amp;a);
    cout &lt;&lt; "After swap(): a: " &lt;&lt; a &lt;&lt; "b: " 
         &lt;&lt; b &lt;&lt; endl;
    return 0;
}</code></pre>
	    </section>

	</section>

	<section>

	  <section id="dynamic">
	    <h1>Dynamic Memory<br>Allocation</h1>
	  </section>

	  <section>
	    <h2>Static Memory Allocation</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Amount of space (memory) already known</li>
	    </ul>
<pre><code data-trim>// declare array of 10 elements 
int someArray[10];

// declare a pointer to int
int *value1_address = &amp;someArray[3];</code></pre>
	  </section>

	  <section>
	    <h2>Dynamic Memory Allocation</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Don't know how much memory is needed in advance</li>
	      <li>Need to create the space on the fly</li>
	      <li>new
		<ul>
		  <li>returns a pointer to newly created "thing"</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>Dynamic Arrays</h2>
	    <p>&nbsp;</p>
<pre><code data-trim>int main() {
    int n;
    // read in a value from the user
    cout &lt;&lt; "Please enter an integer value: " ;
    cin &gt;&gt; n;

    // use the user's input to create an array of int using new
    int * ages = new int [n];</code></pre>
	  </section>

	  <section>
	    <h2>Dynamic Arrays, take 2</h2>
	    <p>&nbsp;</p>
<pre><code data-trim>    // use a loop to prompt the user to initialize the array
    for (int i=0; i &lt; n; i++) {
        cout &lt;&lt; "Enter a value for ages[ " &lt;&lt; i &lt;&lt; " ]: ";
        cin &gt;&gt; ages[i];
    }

    // print out the contents of the array
    for(int i=0; i&lt;n; i++) {
        cout &lt;&lt; "ages[ " &lt;&lt; i &lt;&lt; " ]: " &lt;&lt; ages[i];

    // finished with the array
    //clean up the memory used by calling delete
    delete [] ages;
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>Output</h2>
	    <p>&nbsp;</p>
	    <p>(image)</p>
	  </section>

	  <section>
	    <h2>C++ Syntax: new</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>General form</li>
	      <li>SomeTypePtr = new SomeType;</li>
	      <li>Examples
		<ul>
		  <li>int * intPointer = new int;</li>
		  <li>Rational * rPointer = new Rational;</li>
		  <li>int * intPointer2 = new int(0);</li>
		  <li>Rational * rPointer2 = new Rational(1,2);</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>Memory Management</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Java is garbage collected
		<ul>
		  <li>Allocated memory is automatically reclaimed, programmer does not need to think about it</li>
		</ul></li>
	      <li>C++ does not have garbage collection
		<ul>
		  <li>Programmer must reclaim that memory, otherwise that memory can't be used</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ Syntax: delete</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>delete 
		<ul>
		  <li>delete rPointer</li>
		  <li>delete intPointer</li>
		</ul></li>
	      <li>delete []
		<ul>
		  <li>delete [] ages</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>delete</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>#include &lt;string&gt;
using namespace std;
int main() {
    string * pointerToString = new string("hi");
    // some code that uses pointerToString here
    delete pointerToString;
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>Remember this...</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Anything allocated with new MUST be deallocated with delete</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Accessing parts of an object</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>For a regular (i.e., non-pointer) object, use a period:</li>
	    </ul>
<pre><code data-trim>Rational r;
r.num = 4;</code></pre>
	    <ul>
	      <li>For a pointer, dereference it first (as *r is the object, and r is the pointer):</li>
	    </ul>
<pre><code data-trim>Rational *r = new Rational();
r.num = 4;</code></pre>
	    <ul>
	      <li>A shorthand for the last line is below (the arrow means "follow the pointer"):</li>
	    </ul>
<pre><code data-trim>r->num = 4;</code></pre>
	    <ul>
	      <li>References (which we haven't seen yet) work like regular objects</li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ and memory allocation</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Assume int *x has been declared
		<ul>
		  <li>And int y is from user input</li>
		</ul></li>
	      <li>Consider these separate C++ lines of code:
		<ul>
		  <li>x = new int[10];        // 40 bytes</li>
<li>x = new int;            // 4 bytes</li>
		  <li>x = new int[y];            // y*4 bytes</li>
		</ul></li>
	      <li>When they are deleted, how does C++ know how much memory to free up?</li>
	    </ul>
	  </section>

	  <section>
	    <h2>C++ and memory allocation</h2>
	    <p>&nbsp;</p>
<pre><code data-trim>#include &lt;iostream&gt;
using namespace std;

class Foo {
  int x, y;
};

int main() {
    cout &lt;&lt; "sizeof(int): " &lt;&lt; sizeof(int) &lt;&lt; endl;
    cout &lt;&lt; "sizeof(Foo): " &lt;&lt; sizeof(Foo) &lt;&lt; endl;

    Foo *foo = new Foo();
    Foo *bar = new Foo();

    cout &lt;&lt; "1st Foo: " &lt;&lt; foo &lt;&lt; endl;
    cout &lt;&lt; "2nd Foo: " &lt;&lt; bar &lt;&lt; endl;

    int diff = ((int)bar)-((int)foo);

    cout &lt;&lt; "Difference: " &lt;&lt; diff &lt;&lt; endl;

    delete foo;
    delete bar;
    return 0;
}</code></pre>

<pre><code data-trim>Result:
    sizeof(int): 4
    sizeof(Foo): 8
    1st Foo: 0x6a0670
    2nd Foo: 0x6a0680
    Difference: 16</code></pre>
	  </section>

	  <section>
	    <h2>Associativity of *</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Consider:
		<ul>
		  <li>char*  x, y;</li>
		</ul></li>
	      <li>We can all agree that x is a character pointer (32 bits)</li>
	      <li>But what type is y?
		<ul>
		  <li>It's a regular char (8 bits)</li>
		</ul></li>
	      <li>The * is right associative, meaning that the spacing should be:
		<ul>
		  <li>char  *x, y;</li>
		</ul></li>
	      <li>This won't be consistent in this course...</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Doubly linked lists (lab 2)</h2>
	    <p>&nbsp;</p>
<p>(image)</p>
	  </section>

	  <section>
	    <h2>friend</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Sometimes other classes need access to private data members of another class</li>
	      </ul>
	    <pre><code data-trim>class ListNode {
  public:
    // ...
  private:
  ListNode *next, *previous;
  friend class List;
};</code></pre>
	  </section>

	  <section>
	    <h2>Common mistakes</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Consider a class Foo with an uninitialized ListNode* field list that needs to be initialized in the constructor.</li>
	      <li>What is wrong with the following two methods?</li>
	      <li>They both compile just fine</li>
	    </ul>
	    <pre><code data-trim>Foo() {
ListNode* list = new ListNode();
}</code></pre>
	    <p>&nbsp;</p>
	    <pre><code data-trim>Foo() {
    ListNode temp;
    list = &amp;temp;
}</code></pre>
	  </section>

	</section>

	<section>

	  <section id="references">
	    <h1>References</h1>
	  </section>

	  <section>
	    <h2>References</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Declaring a reference</li>
	    </ul>
	    <pre><code data-trim>List sampleList
List &amp; theList = sampleList;</code></pre>
	    <ul>
	      <li>Reference to a List object</li>
	      <li>What is a reference?</li>
	      <li>Like a pointer, it holds an address, BUT...
		<ul>
		  <li>Its address cannot change (its address is constant)</li>
		  <li>It MUST be initialized upon declaration (cannot be initialized to NULL... normally...)</li>
		  <li>Has implicit dereferencing</li>
		</ul></li>
	    </ul>
	  </section>

	  <section>
	    <h2>swap() with Pointers</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>void swap(int * x, int * y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}</code></pre>
	    <ul>
	      <li>Programmer must specify dereferencing explicitly</li>
	      </ul>
	  </section>

	  <section>
	    <h2>swap with References</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>void swap(int &amp; x, int &amp; y) {
    int temp = x;
    x = y;
    y = temp;
}</code></pre>
	    <ul>
	      <li>Dereferencing is implied with each use</li>
	      <li>All Java non-primitive types are references</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Calling swap() with references</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>int main() {
    int a=0;
    int b=3;
    cout &lt;&lt; "Before swap(): a: " &lt;&lt; a &lt;&lt; "b: "
         &lt;&lt; b &lt;&lt; endl;
    swap(b,a);
    cout &lt;&lt; "After swap(): a: " &lt;&lt; a &lt;&lt; "b: " 
         &lt;&lt; b &lt;&lt; endl;
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>Accessing Members of An Object</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>class Square {
  public:
    // constructors, etc. would be here
    int sideLength;
};</code></pre>
	  </section>

	  <section>
	    <h2>Accessing Members through a Pointer</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>// other code omitted for space reasons
int main() {
    Square *squarePtr = new Square(1);
    int length = squarePtr-&gt;sideLength;
// equivalent to saying (*squarePtr).sideLength
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>Accessing Members through a Reference</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>// other code omitted for space reasons
int main() {
    Square square = Square(1);
    Square &amp; squareRef = square;
    int length = squareRef.sideLength; // uses a period
    return 0;
}</code></pre>
	  </section>

	  <section>
	    <h2>Accessing Pointers within Objects</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>class example1 {
    ...
  public:
    int *a;
};
...
example1 *c = new example1;
int x = 0;
(*c).a = &amp;x; // assign address of x
c-&gt;a = &amp;x; // defrerence c, then access a</code></pre>
	  </section>

	  <section>
	    <h2>Pointer/Reference Cheat Sheet</h2>
	    <p>&nbsp;</p>
	    <p>(table)</p>
	  </section>

	</section>

	<section>

	  <section id="parameters">
	    <h1>Parameter Passing</h1>
	  </section>

	  <section>
	    <h2>Call By Value</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Actual argument is copied into formal parameter
	    </ul>
	    <pre><code data-trim>int max(int a, int b);
void swap (int * x, int *y);
bool compare(Rational left, Rational right);</code></pre>
	    <ul>
	      <li>Can also pass pointers by value</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Call By Reference</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Pass references as parameters</li>
	      </ul>
	    <pre><code data-trim>void swap (int &amp;x, int &amp;y);</code></pre>
	    <ul>
	      <li>Use when formal parameter should be able to change the value of the actual argument</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Call By Constant Reference</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Parameters are constant (won't change) and are passed by reference</li>
	      </ul>
	    <pre><code data-trim>bool compare(const Rational &amp; left, const Rational &amp; right);</code></pre>
	    <ul>
	      <li>Use when there is a class type that cannot be changed by formal parameter</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Other parameter passing types</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Call by copy-restore</li>
	      <li>Call by name</li>
	      <li>Call by need</li>
	      <li>Call by macro expansion</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Return Passing</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Return by value
		<ul>
		  <li>return a copy (possibly a copy of the pointer)</li>
		</ul></li>
	      <li>Return by reference
		<ul>
		  <li>return a reference</li>
		</ul></li>
	      <li>Return by constant reference</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Review: Dynamic Memory Allocation</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>new
		<ul>
		  <li>Allocates a new memory location for use</li>
		  <li>Example:</li>
		</ul>
	      </li>
	    </ul>
<pre><code data-trim>Square * ptrToAnotherSquare = new Square(5);
Triangle *ptrToTriangle = new Triangle();
Circle *ptrToCircle = new Circle;</code></pre>
	    <ul>
	      <li>delete
		<ul>
		  <li>Reclaims memory allocated with new</li>
		  <li>Example:</li>
		</ul>
	      </li>
	    </ul>
	    <pre><code data-trim>delete ptrToAnotherSquare;</code></pre>
	  </section>

	  <section>
	    <h2>The Big Three</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>C++ Provides These By Default
		<ul>
		  <li>Destructor</li>
		  <li>Copy Constructor</li>
		  <li>operator=</li>
		</ul></li>
	      <li>There are some problems with the defaults...</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Destructors</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Called whenever an object 
		<ul>
		  <li>goes out of scope, or</li>
		  <li>delete is called</li>
		</ul></li>
	      <li>Frees up any resources allocated during the use of an object</li>
	      <li>Example (only prototype shown): ~IntCell();</li>
	    </ul>
	  </section>

	  <section>
	    <h2>Copy Constructor</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>Special constructor that creates a new object, initialized to a copy of the same type of object</li>
	      <li>Called in the following situations:
		<ul>
		  <li>declaration with initalization</li>
		  <li>IntCell copy = original; IntCell copy(original);</li>
		</ul>
	      </li>
	      <li>if object is passed by value</li>
	      <li>if object is returned by value</li>
	    </ul>
	  </section>

	  <section>
	    <h2>operator=</h2>
	    <p>&nbsp;</p>
	    <ul>
	      <li>aka copy assignment operator</li>
	      <li>Intended to copy the state of original into copy</li>
	      <li>Called when = is applied to two objects AFTER both have previously been constructed</li>
	      </ul>
	    <pre><code data-trim>IntCell original;    // constructor called
IntCell copy;
copy = original;    // operator= called</code></pre>
	  </section>

	</section>

	<section>

	  <section id="advanced">
	    <h1>Sample (advanced) code</h1>
	  </section>

	  <section>
	    <h2>test.h</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>class test {
    static int idcount;
    const int id;
    int value;
public:
    test();
    test(int v);
    test(const test&amp; x);
    ~test();
    test&amp; operator=(const test&amp; other);
    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const test&amp; f);
};</code></pre>
	  </section>

	  <section>
	    <h2>test.cpp 1/2</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>int test::idcount = 0;

test::test() : id (idcount++), value(0) { 
    cout &lt;&lt; "calling test(); object created is " &lt;&lt; *this
         &lt;&lt; "; address is " &lt;&lt; this &lt;&lt; endl; 
}

test::test(int v) : id (idcount++), value(v) { 
    cout &lt;&lt; "calling test(" &lt;&lt; v &lt;&lt; "); object created is " &lt;&lt; *this 
         &lt;&lt; "; address is " &lt;&lt; this &lt;&lt; endl;
}

test::test(const test&amp; x) : id(x.id), value(x.value) {
    cout &lt;&lt; "calling test(&amp;test) on " &lt;&lt; *this &lt;&lt; "; address is " 
         &lt;&lt; this &lt;&lt; endl;
}</code></pre>
	  </section>

	  <section>
	    <h2>test.cpp 2/2</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>test::~test() {
    cout &lt;&lt; "calling ~test() on " &lt;&lt; *this &lt;&lt; endl;
}

test&amp; test::operator=(const test&amp; other) {
    cout &lt;&lt; "calling operator=(" &lt;&lt; other &lt;&lt; ")" &lt;&lt; endl;
    test *tmp = new test(other);  
    return *tmp;
}

ostream&amp; operator&lt;&lt;(ostream&amp; out, const test&amp; f) {
    out &lt;&lt; "test[id=" &lt;&lt; f.id &lt;&lt; ",v=" &lt;&lt; f.value &lt;&lt; "]";
}</code></pre>
	  </section>

	  <section>
	    <h2>The one subroutine...</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>test bar(test param) {
  return test(10);
}</code></pre>
	  </section>

	  <section>
	    <h2>main() code and output, 1/6</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>test a();
cout &lt;&lt; "attempted to create a: " &lt;&lt; a &lt;&lt; endl;

cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
test aa;
cout &lt;&lt; "created aa: " &lt;&lt; aa &lt;&lt; endl;</code></pre>
	  </section>

	  <section>
	    <h2>main() code and output, 2/6</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
test b(1);
cout &lt;&lt; "created b: " &lt;&lt; b &lt;&lt; endl;</code></pre>
	  </section>

	  <section>
	    <h2>main() code and output, 3/6</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
test *c = new test(2);
cout &lt;&lt; "created *c: " &lt;&lt; *c &lt;&lt; " at " &lt;&lt; c &lt;&lt; endl;
test *d = new test;
cout &lt;&lt; "created *d: " &lt;&lt; *d &lt;&lt; " at " &lt;&lt; d &lt;&lt; endl;</code></pre>
	  </section>

	  <section>
	    <h2>main() code and output, 4/6</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
cout &lt;&lt; "about to invoke subroutine..." &lt;&lt; endl;
test e = bar(*c);
cout &lt;&lt; "finished invoking subroutine..." &lt;&lt; endl;</code></pre>
	  </section>

	  <section>
	    <h2>main() code and output, 5/6</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
test f = b;

cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
cout &lt;&lt; "about to delete a test object..." &lt;&lt; endl;
delete c;</code></pre>
	  </section>

	  <section>
	    <h2>main() code and output, 6/6</h2>
	    <p>&nbsp;</p>
	    <pre><code data-trim>cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
cout &lt;&lt; "assignment..." &lt;&lt; endl;
aa = b;

cout &lt;&lt; "----------------------------------------" &lt;&lt; endl;
    cout &lt;&lt; "about to leave main..." &lt;&lt; endl;</code></pre>
	    </section>

	</section>
	
      </div>

    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.min.js"></script>
    <script src="settings.js"></script>

  </body>
</html>
