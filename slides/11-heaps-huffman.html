<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS 2150: 11-heaps-huffman slide set</title>
    <meta name="description" content="A set of slides for a course on Program and Data Representation">
    <meta name="author" content="Aaron Bloomfield">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="reveal.js/css/reveal.min.css">
    <link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
    <link rel="stylesheet" href="css/pdr.css">
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css"><!-- For syntax highlighting -->
    <script><!-- If the query includes 'print-pdf', include the PDF print sheet -->
	if( window.location.search.match( /print-pdf/gi ) ) {
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = 'reveal.js/css/print/pdf.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	}
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
    <script type="text/javascript" src="js/dhtmlwindow.js"></script>
    <script type="text/javascript" src="js/canvas.js"></script>
    <link rel="stylesheet" href="css/dhtmlwindow.css" type="text/css">
  </head>

  <body onload="canvasinit()">
    <div id="dhtmlwindowholder"><span style="display:none"></span></div>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section data-markdown id="cover"><script type="text/template">
# CS 2150
&nbsp;
### Program and Data Representation
### Spring 2014
&nbsp;
<center><small>[Aaron Bloomfield](http://www.cs.virginia.edu/~asb) / [aaron@virginia.edu](mailto:aaron@virginia.edu) / [@bloomfieldaaron](http://twitter.com/bloomfieldaaron)</small></center>
<center><small>Repository: [github.com/aaronbloomfield/pdr](http://github.com/aaronbloomfield/pdr) / [&uarr;](index.html) / <a href="11-heaps-huffman.html?print-pdf"><img class="print" width="20" src="images/print-icon.png"></a></small></center>
<center><small>Themes: [default](?#/cover), [sky](?theme=sky#/cover), [beige](?theme=beige#/cover), [simple](?theme=simple#/cover), [serif](?theme=serif#/cover), [night](?theme=night#/cover), [moon](?theme=moon#/cover), [solarized](?theme=solarized#/cover)</small></center>
&nbsp;  
&nbsp;  
## Heaps (Priority Queues) & Huffman Coding
	</script></section>

	  <section>
<h2>CS 2150 Roadmap</h2>
<table class="wide">
  <tr><td colspan="3"><p class="center">Data Representation</p></td><td></td><td colspan="3"><p class="center">Program Representation</p></td></tr>
  <tr>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>string<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>int x[3]<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>char x<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>0x9cd0f0ad<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>01101011</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/red-double-arrow.png" height="500" alt="vertical red double arrow"></td>
    <td class="top">&nbsp;<br>Objects<br>&nbsp;<br>Arrays<br>&nbsp;<br>Primitive types<br>&nbsp;<br>Addresses<br>&nbsp;<br>bits</td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>Java code<br>&nbsp;<br>&nbsp;<br>C++ code<br>&nbsp;<br>&nbsp;<br>C code<br>&nbsp;<br>&nbsp;<br>x86 code<br>&nbsp;<br>&nbsp;<br>IBCM<br>&nbsp;<br>&nbsp;<br>hexadecimal</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/green-double-arrow.png" height="500" alt="vertical green double arrow"></td>
    <td class="top">&nbsp;<br>High-level language<br>&nbsp;<br>Low-level language<br>&nbsp;<br>Assembly language<br>&nbsp;<br>Machine code</td>
  </tr>
</table>
	  </section>

	<section data-markdown><script type="text/template">
# Contents
&nbsp;  
[Priority Queues](#priorityqueues)  
[Binary Heaps](#heaps)  
[Heap Operations](#heapops)  
[File Compression](#filecomp)  
[Huffman Coding](#huffman)  
[Priority Queue Example](#priorityqueueex)  
	</script></section>

	<section>

	  <section id="priorityqueues" data-markdown><script type="text/template">
# Priority Queues
	  </script></section>

	  <section data-markdown><script type="text/template">
## Motivation
- Multiuser environment
  - Operating system must choose which process to run on CPU 
- Management of limited resources
  - Bandwidth on network router
    - Limited bandwidth, but want to give best possible performance
    - Send traffic from highest priority queue first
      - Example: VoIP
	  </script></section>

	  <section data-markdown><script type="text/template">
## Priority Queue ADT - Model
- operations: 
  - insert
    - inserts with a *priority*
  - findMin
    - finds the minimum element
  - deleteMin 
    - finds, returns, and removes minimum element
![heap cloud](images/11-heaps-huffman/heap-diagram.svg)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Implementations of Priority Queue ADT

| Data structure | insert | findMin | deleteMin |
|-|-|-|-|
| Unsorted array | &Theta;(1) ammortized | &Theta;(*n*) | &Theta;(*n*) |
| Unsorted linked list | &Theta;(1) | &Theta;(*n*) | &Theta;(*n*) |
| Sorted array | &Theta;(*n*) | &Theta;(1) | &Theta;(1) or &Theta;(*n*) |
| Sorted linked list | &Theta;(*n*) | &Theta;(1) | &Theta;(1) |
| Binary search tree | &Theta;(*n*) | &Theta;(*n*) | &Theta;(*n*) |
| AVL or red-black tree | &Theta;(log *n*) | &Theta;(log *n*) | &Theta;(log *n*) |
| Hash table | ideally constant | &Theta;(*n*) | &Theta;(*n*) |

- We would like:
  - Insert worst case &Theta;(log *n*), average case constant
  - deleteMin worst and average case &Theta;(log *n*)
	  </script></section>

	</section>

	<section>

	  <section id="heaps" data-markdown><script type="text/template">
# Binary Heaps
	  </script></section>

	  <section data-markdown><script type="text/template">
## Binary Heap
- A binary heap is a data structure that is one possible implementation of a priority queue
- It's a binary tree (*not* a BST), with a different:
  - structure property
  - ordering property
	  </script></section>

	  <section data-markdown><script type="text/template">
## Definitions
A Perfect (or Complete) binary tree is a binary tree with all leaf nodes at the same depth; all internal nodes have 2 children.
![heap 1](graphs/heap-1.svg)

- This has height *h*, 2<sup>*h*+1</sup>-1 nodes, 2<sup>*h*</sup>-1 non-leaves, and 2<sup>*h*</sup> leaves
- Note that this example is a complete binary tree, not a heap
	  </script></section>

	  <section data-markdown><script type="text/template">
## Full Binary Tree
- A binary tree in which each node has exactly zero or two children. 
  - Also known as a proper binary tree
  - We will use this later for Huffman trees
![heap 2](graphs/heap-2.svg)
	  </script></section>

	  <section>
<h2>Heap Structure Property</h2>
<p>A binary heap is an <i>almost complete</i> binary tree, which is a binary tree that is completely filled, with the possible exception of the bottom level, which is filled left to right.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<table class="transparent"><tr><td><img alt="heap 3" src="graphs/heap-3.svg"></td><td style="width:50px"></td><td><img alt="heap 4" src="graphs/heap-4.svg"></td></tr></table>
	  </section>

	  <section>
<h2>Almost complete binary tree of height <i>h</i></h2>
<table class="transparent">
<tr><td class="middle" style="text-align:left"><ul><li>For <i>h</i> = 0, just a single node</li></ul></td><td><img alt="heap 5" src="graphs/heap-5.svg"></td><td></td></tr>
<tr><td class="middle" style="text-align:left"><ul><li>For <i>h</i> = 1, left child or two children</li></ul></td><td><img alt="heap 6" src="graphs/heap-6.svg"></td><td><img alt="heap 7" src="graphs/heap-7.svg"></td></tr>
<tr><td colspan="3">
<ul>
<li>For <i>h</i> &ge; 2, either:<ul>
    <li>the left subtree of the root is full with height <i>h</i>-1 and the right is complete with height <i>h</i>-1, OR</li>
    <li>the left is complete with height <i>h</i>-1 and the right is full with height <i>h</i>-2.</li></ul></li>
</ul>
</td></tr></table>
	  </section>

	  <section>
<h2>Representing Complete Binary Trees in Arrays</h2>
<table class="transparent">
<tr><td class="top"><img alt="heap 8" src="graphs/heap-8.svg"></td>
<td>
<p>&nbsp;</p>
<p>From node <i>i</i>:</p>
<p>&nbsp;</p>
<p>left child: 2*<i>i</i></p>
<p>right child: (2*<i>i</i>)+1</p>
<p>parent: floor(<i>i</i>/2)</p>
</td></tr></table>
<p>Implicit (array) representation:</p>

<table class="transparent" style="border-collapse:collapse"><tr class="bordercfifty"><td>&nbsp;</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td><td>K</td><td>L</td><td>&nbsp;</td></tr>
<tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td></tr>
</table>

	  </section>

	  <section data-markdown><script type="text/template">
## Why better than pointers?
- No pointers â€“ saves space
- \*2, /2, + operations are faster than dereferencing pointer
- Parent easy to locate
	  </script></section>

	  <section>
<h2>Heap Order Property</h2>
<p>Heap order property: For every non-root node X, the key in the parent of X is less than (or equal to) the key in X.  Thus, the tree is <i>partially</i> ordered.</p>
<table class="transparent"><tr>
<td class="top"><img alt="heap 9" src="graphs/heap-9.svg"> not a heap</td><td style="width:50px"></td><td><img alt="heap 10" src="graphs/heap-10.svg"> min-heap</td></tr>
</table>
	  </section>

	</section>


	<section>

	  <section id="heapops" data-markdown><script type="text/template">
# Heap Operations
	  </script></section>

	  <section data-markdown><script type="text/template">
## Heap Operations
- findMin: just look at the root node
- insert(val): percolate up
- deleteMin: percolate down  
&nbsp;  
See [here](http://people.ksp.sk/~kuko/bak/index.html) for a good heap animation site
![heap 11](graphs/heap-11.svg)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Heap â€“ Insert(val)
Basic Idea: 

1. Put val at "next" leaf position
2. Repeatedly exchange node with its parent if needed
	  </script></section>

	  <section data-markdown><script type="text/template">
## insert(int x)
```
void insert (int x) {
    if(currentSize == array.size() â€“ 1)
      array.resize(array.size() * 2);

    // Percolate up
    int hole = ++currentSize;
    for( ; hole > 1 && x < array[hole /2]; hole /= 2) {
        // if x < array[hole/2] move 
        // item in array[hole] "down"
        array[hole] = array[hole/2];
    }

    array[hole] = x;
}
```
	  </script></section>

	  <section>
<h2>Insert: percolate up</h2>
<table class="transparent"><tr><td><img alt="heap 12" src="graphs/heap-12.svg"></td><td class="middle">&rarr;</td><td><img alt="heap 13" src="graphs/heap-13.svg"></td></tr></table>
	  </section>

	  <section>
<h2>Insert expected running time</h2>
<ul>
<li>How far to move up?<ul>
  <li>Half of the nodes are leaves, so half of the inserts will only move up one level</li>
  <li>A quarter of the nodes are one level above the leaves, so one quarter of the inserts will move up two levels</li>
  <li>One eighth will require moving up 3 levels</li>
  <li>One sixteenth will require moving up 4 levels</li>
  <li>Etc.</li></ul></li>
<li>Expected running time:<br>&nbsp;</li>
<ul>
\( \frac{1}{2}*1 + \frac{1}{4}*2 + \frac{1}{8}*3 + \ldots = \sum_{i=1}^{n} \frac{1}{2^n}*n = 2 \)
	  </section>

	  <section data-markdown><script type="text/template">
## Heap â€“ DeleteMin
Basic Idea: 

1. Remove root (that is always the min!)
2. Put "last" leaf node at root
3. Find smallest child (why?)
4. Swap node with smallest child if needed.
5. Repeat steps 3 & 4 until no swaps needed.
	  </script></section>

	  <section>
<h2>Which child to swap with</h2>
<table class="transparent">
<tr><td class="middle" style="text-align:left"><ul><li>Consider this min-heap:<ul>
	  <li>25 needs percolating!</li>
	  <li>But which way?</li></ul></li>
  </ul></td><td><img alt="heap 14" src="graphs/heap-14.svg"></td></tr>
<tr><td class="middle" style="text-align:left"><ul><li>If we swap 25 with the smallest child:<ul>
	  <li>All's good!</li></ul></li>
  </ul></td><td><img alt="heap 15" src="graphs/heap-15.svg"></td></tr>
<tr><td class="middle" style="text-align:left"><ul><li>If we swap 25 with the largest child:<ul>
	  <li>No longer a min-heap!</li></ul></li>
  </ul></td><td><img alt="heap 16" src="graphs/heap-16.svg"></td></tr>
</table>
	  </section>

	  <section>
<h2>DeleteMin: percolate down</h2>
<table class="transparent"><tr><td><img alt="heap 17" src="graphs/heap-17.svg"></td><td class="middle">&rarr;</td><td><img alt="heap 18" src="graphs/heap-18.svg"></td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## Other Heap Operations
- `decreaseKey(process, amount)`: "raise" the priority of a process, percolate up
- `increaseKey(processID, amount)`: "lower" the priority of a process, percolate down
- `remove(processID)`: remove a process, move to top, then delete.   
  1. `decreaseKey(processID, -infinity)`
  2. `deleteMin()`  
&nbsp;  
- Worst case Running time for all of these: &Theta;(*n*), because of the find() required; without the find(), itâ€™s &Theta;(log *n*)
- What about FindMax?
- ExpandHeap: when heap fills, copy into new space.
	  </script></section>

	  <section data-markdown><script type="text/template">
## Heaps (Summary)
- insert: percolate up; &Theta;(log *n*) time.
- deleteMin: percolate down; &Theta;(log *n*) time  
&nbsp;  
- Heapsort?
  - Insert *n* elements, then remove n elements
  - Each one has an insertion time of log *n*
  - And then a removal time of log *n*
  - Hence &Theta;(*n* log *n*)
	  </script></section>

	  <section>
<h2>An xkcd about heaps...</h2>
<img class="stretch" src="http://imgs.xkcd.com/comics/tree.png" title="Not only is that terrible in general, but you just KNOW Billy&#39;s going to open the root present first, and then everyone will have to wait while the heap is rebuilt." alt="Tree" />
<p class="center"><a href="http://xkcd.com/835/">xkcd # 835</a></p>
	  </section>

	</section>


	<section>

	  <section id="filecomp" data-markdown><script type="text/template">
# File Compression
	  </script></section>

	  <section data-markdown><script type="text/template">
Data Compression:  
Huffman Coding
10.1.2 in Weiss
Why compress files?
Disk space is limited
File transfer
Bigger files take longer to transfer
Smaller file might fit in memory more easily
What is a file?
Named collection of information
C++ program
Application executables
Word documents
Email
Web pages
Pictures, audio, video
Data Compression



Lossless compression  X = Xâ€™
Lossy compression  X != Xâ€™
information is lost (irreversible)
Compression Ratio  |X|/|Y|
Where |X| is the # of bits in X.
Lossy Compression
Some data is lost, but not too much.
Standards:
JPEG (Joint Photographic Experts Group)
Still images
MPEG (Motion Picture Experts Group) 
Audio and video
MP3 (MPEG-1, Layer 3), Ogg vorbis

JPEG image quality 
comparison
Quality = 100
Image size: 83,261 (100%)
Quality = 50
Image size: 15,138 (18%)
Quality = 25 
Image size: 9,553 (11%)
Quality = 10
Image size: 4,787 (6%)
Quality = 1
Image size: 1,523 (2%)
Lossless Compression
No data is lost.

Standards:
Gzip, Unix compress, zip, Morse code 
PNG image file formats
Run-length encoding (RLE)
Lossless Compression of Text
ASCII = fixed 8 bits per character
Example: "hello there"
11 characters * 8 bits = 88 bits

Can we encode this message using fewer bits?

Huffman Coding
Uses frequencies of symbols in a string to build a prefix code.

The more frequent a character is, the fewer bits weâ€™ll use to represent it

Prefix Code â€“ no code in our encoding is a prefix of another code.
Decoding a Prefix Code
Create the Huffman coding tree
Loop
	start at root of tree
		loop
			if bit read = 1 then go right
			else, go left
		until node is a leaf 
		Report character found!
Until end of the message

Decode: 1110001010011
Huffman Trees
Cost of a Huffman Tree containing n symbols

	C(T) = p1*r1+p2*r2+p3*r3+â€¦.+ pn*rn

Where:
pi = the probability that a symbol occurs
ri = the length of the path from the root to the node
Huffman encoding costs
This is the example from 2 slides ago
	  </script></section>

	</section>


	<section>

	  <section id="huffman" data-markdown><script type="text/template">
# Huffman Coding
	  </script></section>

	  <section data-markdown><script type="text/template">
Huffman Encoding
Compression Phase
Determine the frequencies of the characters stored in the source file.
Read the source file  
Then store the character frequencies in a min-heap 
Build a tree of prefix codes (a Huffman code) that determines the unique bit codes for each character.
Write the prefix codes or code tree to the output file.
Re-read the source file and for each character read, write its prefix code into the output file. 
You must WRITE the prefix code/tree and the encoded file to the SAME output file
Huffman coding example
From Weiss, page 416
Uses 5 letters (a, e, i, s, t), plus the space and the newline
Total of 58 characters
Normal ASCII encoding is 8 bits per character
58*8 = 464 bits
Which is 58 bytes, obviously
Straight encoding is 3 bits per character
58*3 = 174 bits
Which is 21.75 bytes
Compression step 1 (a)
Determine frequencies of letters
Compression step 1 (b)
Build a min-heap
Sorted by frequency
Compression step 2
Build the tree
Start with a "forest" of trees:


Repeat
Take the two trees that have the lowest frequency
The next two removals from the heap
Make them children of a new node
Keep track of the total frequency of that node
And stick that tree back into the heap


The final Huffman coding tree
Resulting encoding table









Total encoding is 146 bits
ASCII was 464 bits: compression ratio of 3.2:1
Straight encoding was 174 bits: compression ratio of 1.2:1
Compression step 3
Write the prefix codes to a file
Weâ€™ll use regular ASCII characters
Does this actually do any compression, then?

a 001
e 01
i 10
s 00000
t 0001
(sp) 11
(nl) 00001

Compression step 4
Write the text to the file using the Huffman encoding

sit becomes 00000 10 0001
taste becomes 0001 001 
			00000 0001 01
etc.
Decompression Phase
Read in the prefix code structure (tree or array) from the compressed file. 
Build a new Huffman tree for performing decompression
Read in one bit at a time from the compressed file and move through the prefix code tree until a leaf node is reached.
Write the character stored at the leaf node into the decompressed file.
While there is still input, repeat.
Huffman Coding Lab
Compression (pre-lab)
Decompression (in-lab)
Report (post-lab)
Huffman Encoding Prelab
Write a program that reads input from a file (see class website for test files)
Build a binary heap (priority queue) that calculates the letter frequencies
Build the huffman tree
Print the letter-encoding mapping to the file
There is a specific format, as specified in the lab
Encode the message, printing this also to the file

Tips/Hints
You may use Weiss code, or create your own heap code.
File input/output reference material
readfile.cpp from hashing lab
Class resources page
ASCII
ASCII Character Codes
American Standard Code for Information Interchange (ASCII)
Character encoding standard
Specifies  correspondence between digital bit patterns and English alphabet
7-bit encoding with 1 bit for parity (error correction)
128 characters
95 printable characters
33 non-printable characters

ASCII Character Codes
(Hexadecimal)
	  </script></section>

	</section>


	<section>

	  <section id="priorityqueueex" data-markdown><script type="text/template">
# Priority Queue Example
	  </script></section>

	  <section data-markdown><script type="text/template">
Priority Queues
Priority Queue Operations (Weiss)
insert( x ) 
deleteMin( )
findMin( )
isEmpty( ) 
makeEmpty( )
size( )
Binary Heap Class
template <typename Comparable>
class BinaryHeap { 
	public: 
		BinaryHeap( int capacity = 100 );// Constructor
		BinaryHeap( const vector<Comparable> & items ); 
		bool isEmpty( ) const; 
		const Comparable & findMin( ) const;
		void insert( const Comparable & x ); 
		void deleteMin( );
		void makeEmpty( );
		int size() const;

	private: 
		int currentSize; 	// Number of elements in heap 
		vector<Comparable> list; 	// The heap array 
					// Internal methods
		void buildHeap( ); 	
		void percolateDown( int hole );
}; 
Heap Data Members
int currentSize
Size of the heap
vector <Comparable> list
The heap implemented as an array

Constructors
// Default constructor
BinaryHeap( int capacity = 100 ) : list( capacity + 1 ), currentSize( 0 ) { } 

// Copy constructor
BinaryHeap( const vector<Comparable> & items ) : list( items.size( ) + 10 ), currentSize( items.size( ) ) { 
		for( int i = 0; i < items.size( ); i++ ) 
			list[ i + 1 ] = items[ i ]; 
		buildHeap( ); 
} 
isEmpty()
bool isEmpty( ) const {
	return currentSize == 0; 
} 
findMin()
const Comparable & findMin( ) const { 
	if( isEmpty( ) ) 
		throw UnderflowException( ); 
	return list[ 1 ]; 
} 
insert(x)
void insert( const Comparable & x ) { 
	if( currentSize == list.size( ) - 1 ) 
		list.resize( list.size( ) * 2 ); 
	// Percolate up 
	int hole = ++currentSize; 
	for( ; hole>1 && x<list[hole /2]; hole /= 2 )
		list[ hole ] = list[ hole / 2 ];
	list[ hole ] = x; 
} 
deleteMin()
void deleteMin( ) { 
	if( isEmpty( ) ) 
		throw Underflow( );
	// put last element in the heap at the top
	list[ 1 ] = list[ currentSize-- ]; 
	// percolate down
	percolateDown( 1 ); 
} 
makeEmpty() and size()
void makeEmpty( ) {
	currentSize = 0; 
} 

int size() const {
	return currentSize;
}
buildHeap()
// Internal method
void buildHeap( ) { 
	for( int i = currentSize / 2; i > 0; i-- ) 	
		percolateDown( i ); 
} 
percolateDown()
void percolateDown( int hole ) { 
	int child; 
	Comparable tmp = list[ hole ]; 
	for( ; hole * 2 <= currentSize; hole = child ) { 
		child = hole * 2; 
		if(child!=currentSize && list[child+1] < list[child]) 
			child++;  // look at the min of 2 children
		if( list[ child ] < tmp ) 
			list[ hole ] = list[ child ]; 
		else break;
	} 
	list[ hole ] = tmp; 
} 
	  </script></section>

	</section>



      </div>

    </div>

    <div id="calibratediv" style="display:none">
      <div id="calibratecanvasdiv">
        <canvas id="calibratecanvas" width="300" height="300">Your browser does not support the canvas tag</canvas>
      </div>
      <p style="text-align:center">Click the center of the target<br><a href="#" onClick="calibratewin.close(); return false">Close window</a></p>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.min.js"></script>
    <script src="js/settings.js"></script>

  </body>
</html>
